--- 
layout: post
title:  "Pyrite3D: The Client Side"
author: "Andre Price"
author-link: "https://blog.obsoleted.net/"
date:   2015-09-15 10:00:00
tags: Azure 3D Unity3D Streaming Pyrite3D
color: "blue"
excerpt: "Detailing the Pyrite3D Unity client"
--- 

# Pyrite3D: The Client Side

This case study focuses on the Pyrite3D Client implementation and demo application. You may benefit from first reading the overview case study, [Visualize Large 3D Captures using Pyrite3D](http://partnercatalyst.azurewebsites.net/2015/09/10/Streaming-Meshes-From-Azure.html).

Large scale 3D reconstructions are an important tool in many industries, and it is becoming easier and faster to create these large meshes.  Unfortunately large 3D meshes with corresponding high quality textures are not as easily consumed on reasonable devices using easily accessible tools (e.g. my Dell T3500 using [MeshLab](http://meshlab.sourceforge.net/)). 

In collaboration with [Pix4D](https://pix4d.com/) and [WaldoAir](http://waldoair.com/) we made Pyrite3D to try to bridge this gap between the initial creation of large 3D meshes and their consumption or viewing.  Pyrite3D is an open source framework to process very large 3D models for visualization on downstream less-capable hardware.  Specifically it focuses on the surge in complex 3D models generated by of UAV, Scanner, and Handheld camera hardware that has outstripped  the rendering performance of consumers.  The previous case study referenced above discusses how we can prepare a model for client consumption.  Below I describe our approach to constructing a client to consume this data, and discuss the challenges we faced.

## Our Sample 3D Reconstruction Life-cycle
To understand the benefits provided by leveraging a streaming client solution, it is helpful to understand the data pipeline and where Pyrite3D adds value.
 
Here we will focus on one of the most common ways large meshes are created, from a 3D reconstruction process known as "Structure From Motion". While specific steps and technologies used may differ, the process can be split up into discrete stages: capture, process and consume. The following sections describe these in more detail while giving examples from the test data sets we used for Pyrite.

### Capturing
The capture stage contains the parts of the process that deal with gathering **all** the required data to perform the reconstruction.  Our demo application leverages two sample meshes that were both captured by Waldo Air.  One was is a capture of Nashville, TN and the other is of a small area in Begard, France.

- Captures were made with a WaldoAir XCAM-B Oblique Aerial Imaging System (a small, portable low cost Aerial imaging system made by WaldoAir Corp.)
- The imaging system was attached to a manned aircraft and flown above the target area capturing images
- Nashville: 
	- Taken from 1500 ft. above ground level (AGL)
	- **773 Images** at **18 MP**
	- Raw data size: **5.5 GB**
- Begard:
	- Taken from 1000 ft. AGL
	- **550 Images** at **18 MP**
	- Raw data size: **3.5 GB**

The method of capture used here yields a large set of images and corresponding geographic (GPS) location that is used in the processing stage.

### Processing
This stage takes the raw data gathered from the capture and turns it into a 3D mesh and texture.  For our captures Pix4D was used for processing.  The Pix4D software takes the data and first creates a 3D point cloud using the images and then uses that data to create a 3D mesh and high resolution texture.  This is a resource intensive process that requires significant time and processing power.

Our post processing data-sets were as follows:

Property | Nashville | Begard 
---- | ---- | ----
Texture Size | 49 MB | 46 MB
Texture Resolution | 16348 x 16348 | 16348 x 16348
OBJ Size | 1500 MB | 791 MB
Vertex Count | 10,000,000 | 5,000,000
Face Count | 20,000,000 | 10,000,000

As you can see these are some large meshes.  The Pyrite CLI processor discussed in the other case study describes what happens to get them ready for our client in more detail.  This processing also adds to the overall resource requirements of the processing stage, but it allows benefits later on as you will see.

### Consuming 
Reconstructions are ultimately useless unless you can do something with them.  In our case even simply viewing the generated meshes proves to be difficult.  A popular open source tool for viewing large meshes, MeshLab, takes several minutes to load our Nashville mesh on typical desktop hardware, and fails entirely at loading the texture data. Attempting to navigate the mesh is virtually impossible.

After using Pyrite3D we had the reconstruction in a form that would allow for better performance for some cases but it needed a client.  We chose to make a simple mesh explorer demo with the following goals/requirements:
- Allow navigation around the mesh
- Allow zooming in to enable full detail viewing of areas
- Cross platform to demonstrate/test performance limits

We decided to make a Unity3D application because it easily allowed for cross-platform targeting and allowed for quicker prototyping 3D scenarios such as ours.  You can can get and run the sample on [Windows](https://www.microsoft.com/store/apps/9nblggh1mx9z) or [Android](https://play.google.com/apps/testing/com.microsoft.pyrite). In the next section I'll discuss how the client works and some of the technical solutions we used to make it happen.

## Client Implementation
The client provides simple controls for moving a camera around a scene that contains the reconstruction. In order to hold the balance between performance and seeing the full detail of the model the client works as follows:

- Query the Pyrite server for information about the model it is trying to display
- Based on the results above add "Detection cubes" into the scene corresponding to the lowest level detail segments of the model
- "Detection cubes" are responsible for triggering model loading when visible to the camera
- "Detection cubes" are also responsible for triggering level of detail upgrading based on a configurable distance from the camera
	- This results in the cube being replaced by detection cubes of higher level of detail that are contained in the same model space
- When a model ceases to be visible to the camera it is unloaded and the "detection cube" returns to its original state

Because of the way Pyrite3D partitions the model data with varying level of details having clean boundaries we can mix and match them (at level of detail boundaries) to create a clean visual representation for the camera. 

Using our client to explore the Nashville sample data it takes just **20 MB** to load the initial view of the scene like this 
![Nashville initial load ]({{site.baseurl}}/images/2015-09-17-Pyrite3D-Data-Client-Walkthrough/nashville_initial_load.PNG)

and just **25 MB** more to zoom in and start getting the full detail of some of the mesh.  

![Nashville l1 load ]({{site.baseurl}}/images/2015-09-17-Pyrite3D-Data-Client-Walkthrough/nashville_l1_load.PNG)

The full model is not loaded all at once, but smaller sections of the full resolution mesh are loaded in areas close to the camera to provide a similar experience at a fraction of the data size.

### Technical Challenges/Features


#### Caching
The model data is streamed from the Pyrite server, but the client has mechanisms to avoid unneeded requests and improve performance. We use a series of caching mechanisms at various points in the render pipeline.
- File cache: All model data related requests from the server are persisted to local temporary app storage (with a configurable limit)
- Memory cache: All requests are also stored in a memory cache
- The caches are designed to keep the more recently used data items around while evicting those that have not been referenced in a while

You can see some of the code for this behavior in the [CacheWebRequest](https://github.com/PyriteServer/PyriteDemoClient/blob/master/Assets/Pyrite/Scripts/CacheWebRequest.cs) class which handles the logic of using the file cache or going to the server and in the [DictionaryCache](https://github.com/PyriteServer/PyriteDemoClient/blob/master/Assets/Pyrite/Scripts/DictionaryCache.cs) which provides the core of the LRU cache functionality. 

#### Object Pooling
The client also uses a basic object pool based off the Unity3D [sample](https://unity3d.com/learn/tutorials/modules/beginner/live-training-archive/object-pooling).  This served our purposes just fine but in the future we may consider moving to something with more explicit control around the lifetime of pooled objects instead overloading the active state.

#### Background Thread Usage
Performance takes a big hit the more we do on the UI/Game thread.  As such we attempted to do as much work as possible in background/worker threads.  We did use background threads for parsing and preparing data coming from the server and notifying game threads when it is ready to render.

#### Upgrade/Downgrade detection
To add the "detection cube" functionality mentioned above we leveraged a few of Unity's built in APIs and helpers.
- The [OnWillRenderObject](http://docs.unity3d.com/ScriptReference/MonoBehaviour.OnWillRenderObject.html) method was used to detect when a cube was entering the camera's viewport. 
- Due to the way we implemented our cubes (by disabling their mesh renderer) we could not use similar MonoBehaviour methods to detect a cube going out of the viewport.  So we instead opted to test the cubes intersection with the camera frustum using [TestPlanesAABB](http://docs.unity3d.com/ScriptReference/GeometryUtility.TestPlanesAABB.html) to trigger unloading/hiding of the model segment.  
	- This was also a rather expensive call so we limited its execution to every 100ms
- Upgrading and downgrading of cubes was simply based on the distance to the camera. This distance is configured by modifying a constant factor and offset that would be applied to the segment size (which varies for each level of detail).  This allowed for another way to tweak behavior depending on the performance we were observing for the model being loaded.  This logic is mostly contained within our [IsRendered](https://github.com/PyriteServer/PyriteDemoClient/blob/master/Assets/Pyrite/Scripts/IsRendered.cs) script.


## Conclusions
Pyrite3D can be used to make some client scenarios available in more places than they could have been before.  But it does take some consideration and design when implementing to fully take advantage of the mesh pre-processing the pipeline provides.  All Pyrite3D source is open and up on GitHub [here](https://github.com/PyriteServer).  Feel free to check out it, file issues or contribute.  The demo client is also in the Windows store available [here](https://www.microsoft.com/store/apps/9nblggh1mx9z).