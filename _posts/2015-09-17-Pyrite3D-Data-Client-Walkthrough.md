--- 
layout: post
title:  "Pyrite3D: The Client Side"
author: "Andre Price"
author-link: "https://blog.obsoleted.net/"
date:   2015-09-15 10:00:00
tags: Azure 3D Unity3D Streaming Pyrite3D
color: "blue"
excerpt: "Detailing the Pyrite3D Unity client"
--- 

# Pyrite3D: The Client Side

*This case study is a sequel of sorts to [Visualize Large 3D Captures using Pyrite3D](http://partnercatalyst.azurewebsites.net/2015/09/10/Streaming-Meshes-From-Azure.html). While I will try to provide any needed context here it may help to read that one first.*

Large scale 3D reconstructions are an important tool for many uses and it is getting easier and faster to create these large meshes.  Unfortunately large 3D meshes with corresponding high quality textures are not as easily consumed on reasonable devices using easily accessible tools (e.g. my Dell T3500 using [MeshLab](http://meshlab.sourceforge.net/)). 

In collaboration with [Pix4D](https://pix4d.com/) and [WaldoAir](http://waldoair.com/) we made Pyrite3D to try to bridge this gap between the initial creation of large 3D meshes and their consumption or viewing.  Pyrite3D is an open source framework to process very large 3D models for visualization on downstream less-capable hardware.  Specifically it focuses on the surge in complex 3D models generated by of UAV, Scanner, and Handheld camera hardware that has outstripped rendering performance of consumers.  The previous case study referenced above discusses how we can prepare a model for client consumption.  Below I describe the challenges and our approach to solving them on the client/consumer side of the process.

## Our Sample 3D Reconstruction Life-cycle
Before getting into the details of the client I think it would be helpful to understand some of the process around creating the reconstructions/meshes.  This will also help explain why we thought something like Pyrite3D could add value in the space.
 
3D reconstructions can be created in many ways using a variety of methods. But while specific steps and technologies used may differ the process can be split up into discrete stages: capture, process and consume. The following sections describe these in a bit more detail while giving examples from the test data sets we used for Pyrite.

### Capturing
The capture stage contains the parts of the process that deal with gathering **all** the required data to perform the reconstruction.  We worked primarily with 2 sample meshes that were both captured by Waldo Air.  One was a capture of Nashville, TN and the other was of a small area in Begard, France.  Here are some of the specific details related to the captures:

- Captures were made with a WaldoAir XCAM-B Oblique Aerial Imaging System (a small, portable low cost Aerial imaging system made by WaldoAir Corp.)
- The imaging system was attached to a manned air vehicle and flown above the target area capturing images
- Camera system pixel cross range was 10200 pixels @ **18 MP**
- Nashville: 
	- Taken from 1500 ft. above ground level (AGL)
	- **773 Images**
	- Raw data size: **5.5 GB**
- Begard:
	- Taken from 1000 ft. AGL
	- **550 Images**
	- Raw data size: **3.5 GB**

The method of capture used here yields a large set of images and corresponding geographic (GPS) location that is used in the processing stage.

### Processing
This stage takes the raw data gathered from the capture and turns it into a 3D mesh and texture.  For our captures Pix4D was used for processing.  The Pix4D software takes the data and first creates a 3D point cloud using the images and then uses that data to create a 3D mesh and high resolution texture.  This is a somewhat resource intensive process that usually requires relatively significant time and processing power.

Our data sets ended up with the following properties:

Property | Nashville | Begard 
---- | ---- | ----
Texture Size | 49 MB | 46 MB
Texture Resolution | 16348 x 16348 | 16348 x 16348
OBJ Size | 1.5 GB | 791 MB
Vertex Count | 9875955 | 4991824
Face Count | 19799999 | 9999999

As you can see these are some large meshes.  The Pyrite CLI processor discussed in the other case study describes what happens to get them ready for our client in more detail.  This processing also adds to the overall resource requirements of the processing stage, but it allows benefits later on as you will see.

### Consuming 
Reconstructions are ultimately useless unless you can do something with them.  In our case even simple viewing of the generated meshes proves to be difficult.  MeshLab takes several minutes to load up the Nashville mesh on my computer, fails to load the texture, and then crawls with unacceptable performance when trying to explore the mesh.

After using Pyrite3D we had the reconstruction in a form that would allow for better performance for some cases but it needed a client.  We chose to make a simple mesh explorer demo with the following goals/requirements:
- Allow navigation around the mesh
- Allow zooming in to enable full detail viewing of areas
- Cross platform to demonstrate/test performance limits

We decided to make a Unity3D application because it easily allowed for cross-platform targeting and allowed for quicker prototyping 3D scenarios such as ours.  You can can get and run the sample on [Windows](https://www.microsoft.com/store/apps/9nblggh1mx9z) or [Android](https://play.google.com/apps/testing/com.microsoft.pyrite). In the next section I'll discuss some how the client works and some of the technical solutions we used to make it happen.

## Client Implementation
The client provides simple controls for moving a camera around a scene that contains the reconstruction. In order to hold the balance between performance and seeing the full detail of the model the client works as follows:

- Query the Pyrite server for information about the model it is trying to display
- Based on the results above add "Detection cubes" into the scene corresponding to the lowest level detail segments of the model
- "Detection cubes" are responsible for triggering model loading when visible to the camera
- "Detection cubes" are also responsible for triggering level of detail upgrading based on a configurable distance from the camera
	- This results in the cube being replaced by detection cubes of higher level of detail that are contained in the same model space
- When a model ceases to be visible to the camera it is unloaded and the "detection cube" returns to its original state

Because of the way Pyrite3D partitions the model data with varying level of details having clean boundaries we can mix and match them (at level of detail boundaries) to create a clean visual representation for the camera. 

Using our client to explore the Nashville sample data it takes just **20 MB** to load the initial view of the scene like this 
![Nashville initial load ]({{site.baseurl}}/images/2015-09-17-Pyrite3D-Data-Client-Walkthrough/nashville_initial_load.png)

and just **25 MB** more to zoom in and start getting the full detail of some of the mesh.  

![Nashville l1 load ]({{site.baseurl}}/images/2015-09-17-Pyrite3D-Data-Client-Walkthrough/nashville_l1_load.png)

Obviously we are not loading the full model at high resolution but in terms of what the camera sees it should be quite similar to looking at the original from the same position.  And all for a fraction of the size!

### Technical Challenges/Features


#### Caching
The model data initially comes from the Pyrite server but the client does what it can to avoid unneeded requests as that reduces performance.  To that end we use a series of caches to assist.
- File cache: All model data related requests from the server are persisted to local temporary app storage (with a configurable limit)
- Memory cache: All requests are also stored in a memory cache
- The caches are designed to keep the more recently used data items around while evicting those that have not been referenced in a while

You can see some of the code for this behavior in the [CacheWebRequest](https://github.com/PyriteServer/PyriteDemoClient/blob/master/Assets/Pyrite/Scripts/CacheWebRequest.cs) class which handles the logic of using the file cache or going to the server and in the [DictionaryCache](https://github.com/PyriteServer/PyriteDemoClient/blob/master/Assets/Pyrite/Scripts/DictionaryCache.cs) which provides the core of the LRU cache functionality. 

#### Object Pooling
The client also uses a basic object pool based off the Unity3D [sample](https://unity3d.com/learn/tutorials/modules/beginner/live-training-archive/object-pooling).  This served our purposes just fine but in the future we may consider moving to something with more explicit control around the lifetime of pooled objects instead overloading the active state.

#### Background Thread Usage
Performance takes a big hit the more we do on the UI/Game thread.  As such we attempted to do as much work as possible in background/worker threads.  Initially this led us to try to use more primitive network classes which could be accessed off game thread unlike [WWW](http://docs.unity3d.com/ScriptReference/WWW.html).  However, this turned out to be an issue when trying to move to various platforms as some of them did not have complete implementations of the classes we used or were limited in some critical way.  But we did use background threads for parsing the responses from the server for vertex and face data.

#### Upgrade/Downgrade detection
To add the "detection cube" functionality mentioned above we leveraged a few of Unity's built in APIs and helpers.
- The [OnWillRenderObject](http://docs.unity3d.com/ScriptReference/MonoBehaviour.OnWillRenderObject.html) method was used to detect when a cube was entering the camera's viewport. 
- Due to the way we implemented our cubes (by disabling their mesh renderer) we could not use similar MonoBehaviour methods to detect a cube going out of the viewport.  So we instead opted to test the cubes intersection with the camera frustum using [TestPlanesAABB](http://docs.unity3d.com/ScriptReference/GeometryUtility.TestPlanesAABB.html) to trigger unloading/hiding of the model segment.  
	- This was also a rather expensive call so we limited its execution to every 100ms
- Upgrading and downgrading of cubes was simply based on the distance to the camera. This distance is configured by modifying a constant factor and offset that would be applied to the segment size (which varies for each level of detail).  This allowed for another way to tweak behavior depending on the performance we were observing for the model being loaded.  This logic is mostly contained within our [IsRendered](https://github.com/PyriteServer/PyriteDemoClient/blob/master/Assets/Pyrite/Scripts/IsRendered.cs) script.


## Conclusions
Pyrite3D can certainly be used to make some client scenarios available in more places than they could have been before.  Working on the client was pretty interesting and a great learning experience.  I'm still learning my way around the deeper levels of Unity and hope to make the performance even better going forward.  All Pyrite3D source is open and up on GitHub [here](https://github.com/PyriteServer).  Feel free to check out it, take it for a spin file issues or contribute!

